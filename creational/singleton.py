"""
Одиночка — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр,
и предоставляет к нему глобальную точку доступа.
Одиночка решает сразу две проблемы, нарушая принцип единственной ответственности класса.
1. Гарантирует наличие единственного экземпляра класса.
Представьте, что вы создали объект, а через некоторое время пробуете создать ещё один.
В этом случае хотелось бы получить старый объект, вместо создания нового.
2. Предоставляет глобальную точку доступа.
Это не просто глобальная переменная, через которую можно достучаться к определённому объекту.
Глобальные переменные не защищены от записи, поэтому любой код может подменять их значения без вашего ведома.
Многие программисты считают Одиночку антипаттерном, поэтому его всё реже и реже можно встретить в Python-коде.
Решение:
Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод,
который и будет контролировать жизненный цикл объекта-одиночки.
Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу.
Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и тот же объект.
"""

from threading import Lock, Thread
import psycopg2
from decouple import config


class SingletonMeta(type):
    """Потокобезопасная реализация класса Singleton"""
    _instances = {}
    _lock = Lock()  # объект блокировка для синхронизации потоков

    def __call__(cls, *args, **kwargs):
        """
        Данная реализация не учитывает возможное изменение передаваемых аргументов в `__init__`.
        """
        # Теперь представьте, что программа была только-только запущена.
        # Объекта-одиночки ещё никто не создавал, поэтому несколько потоков
        # вполне могли одновременно пройти через предыдущее условие и достигнуть
        # блокировки. Самый быстрый поток поставит блокировку и двинется внутрь
        # секции, пока другие будут здесь его ожидать.
        with cls._lock:
            # Первый поток достигает этого условия и проходит внутрь, создавая
            # объект-одиночку. Как только этот поток покинет секцию и освободит
            # блокировку, следующий поток может снова установить блокировку и
            # зайти внутрь. Однако теперь экземпляр одиночки уже будет создан и
            # поток не сможет пройти через это условие, а значит новый объект не
            # будет создан.
            print(f"Работает поток с аргументом {args[0]}")
            if cls not in cls._instances:
                instance = super().__call__(*args, **kwargs)
                cls._instances[cls] = instance
                print(f"Поток с аргументом {args[0]} создал объект")

            print(f"Поток с аргументом {args[0]} отработал")


        return cls._instances[cls]


class Singleton(metaclass=SingletonMeta):
    value: str = None
    """
    Поле по которому мы поймем, что наш Одиночка работает
    """

    def __init__(self, value: str) -> None:
        self.value = value

    def connect_to_db(self) -> None:
        try:
            conn = psycopg2.connect(
                dbname=config('DB_NAME'),
                user=config('DB_USER'),
                password=config('DB_PASSWORD'),
                host=config("DB_HOST"),
                port=config("DB_PORT")
            )
            cursor = conn.cursor()
            cursor.execute('SELECT * FROM public.tester_customuser;')
            print(cursor.fetchall())
            cursor.close()
            conn.close()
        except Exception as error:
            print(f'Не удалось подключиться к БД, ошибка: {error}')


def test_singleton(value: str) -> None:
    singleton = Singleton(value)
    singleton.connect_to_db()


if __name__ == '__main__':
    process1 = Thread(target=test_singleton, args=('Test1',))
    process2 = Thread(target=test_singleton, args=('Test2',))
    process1.start()
    process2.start()
